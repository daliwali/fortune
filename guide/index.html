<!DOCTYPE html><!--

This page is automatically generated. See:
https://github.com/fortunejs/fortune/tree/master/website

--><meta charset="utf-8"><title>Guide</title><link rel="icon" href="../assets/fortune_pig.png"><link rel="stylesheet" href="../assets/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.perfect-scrollbar/0.6.12/css/perfect-scrollbar.min.css"><header><div><a href="../"><img src="../assets/fortune_logo.svg" alt="Fortune.js" class="logo-type"></a><a href="https://github.com/fortunejs/fortune" class="corner">GitHub<span> Repository</span></a></div></header><main><article><h1>Guide</h1><p><em>This guide assumes familiarity with Node.js, JavaScript, and databases, and is intended to show how to use Fortune.js effectively.</em></p><p>Fortune.js is a non-native graph database abstraction layer for Node.js and web browsers. It makes assumptions about the data model in order to build features on top of those assumptions:</p><ul><li><strong>Inverse relationship updates</strong>: when using links in the definition of a record type, Fortune.js will automatically write the other side of the link.</li><li><strong>Referential integrity</strong>: Fortune.js ensures that all links must be valid at the application level.</li><li><strong>Type validation</strong>: fields are guaranteed to belong to a single type.</li><li><strong>Adapter interface</strong>: any database driver that can implement the Adapter abstract base class can work with Fortune.js.</li></ul><p>The only required input of Fortune.js are <em>record types</em>, which are analogous to a <code>struct</code> in C-like languages. Record types guarantee that fields must belong to a single type or that they are links. The valid types are native JavaScript types including <code>Buffer</code> from Node.js, and custom types may extend one of the native types. A link must refer to an ID belonging to a single record type. Both types and links may be defined as arrays or singular values.</p><p>Links in record type fields are just primitive values that correspond to the ID of a record in a collection. What is special about links is that Fortune.js automatically manages both sides of the relationship. Writing a link on a record will cause other records to be written as well.</p><h2 id="motivation">Motivation<a class="anchor" href="#motivation" title="Link to this section “Motivation”">#</a></h2><p>Databases implement disparate sets of features, Fortune.js provides common functionality that may not be implemented by the underlying database. The abstraction layer that Fortune.js provides can be extended to network protocols, as HTTP and WebSocket can be exposed using the same application code, using any serialization format.</p><p>There is a misconception that database abstractions are for porting application code to use another database, which rarely is the case. However, this is particularly useful for writing applications that can run anywhere, such as on a server or a client where different databases may be a necessity.</p><h2 id="type-definition">Type Definition<a class="anchor" href="#type-definition" title="Link to this section “Type Definition”">#</a></h2><p>Here is a basic example of record type definitions, which may model a micro-blogging service:</p><pre><code class="language-js"><span class="hljs-keyword">const</span> fortune = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fortune&#x27;</span>)

<span class="hljs-keyword">const</span> recordTypes = {
  <span class="hljs-attr">post</span>: {
    <span class="hljs-attr">text</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">createdAt</span>: <span class="hljs-title class_">Date</span>,
    <span class="hljs-attr">replies</span>: [ <span class="hljs-title class_">Array</span>(<span class="hljs-string">&#x27;post&#x27;</span>), <span class="hljs-string">&#x27;parent&#x27;</span> ],
    <span class="hljs-attr">parent</span>: [ <span class="hljs-string">&#x27;post&#x27;</span>, <span class="hljs-string">&#x27;replies&#x27;</span> ],
    <span class="hljs-attr">author</span>: [ <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;posts&#x27;</span> ]
  },
  <span class="hljs-attr">user</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">password</span>: <span class="hljs-title class_">Buffer</span>,
    <span class="hljs-attr">salt</span>: <span class="hljs-title class_">Buffer</span>,
    <span class="hljs-attr">posts</span>: [ <span class="hljs-title class_">Array</span>(<span class="hljs-string">&#x27;post&#x27;</span>), <span class="hljs-string">&#x27;author&#x27;</span> ],
    <span class="hljs-attr">following</span>: [ <span class="hljs-title class_">Array</span>(<span class="hljs-string">&#x27;user&#x27;</span>), <span class="hljs-string">&#x27;followers&#x27;</span> ],
    <span class="hljs-attr">followers</span>: [ <span class="hljs-title class_">Array</span>(<span class="hljs-string">&#x27;user&#x27;</span>), <span class="hljs-string">&#x27;following&#x27;</span> ]
  }
}

<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">fortune</span>(recordTypes)
</code></pre><p>This is already very close to a working web application. The rest of this guide will focus on all of the parts which are relevant for building this hypothetical application.</p><h2 id="adapter-interface">Adapter Interface<a class="anchor" href="#adapter-interface" title="Link to this section “Adapter Interface”">#</a></h2><p>By default, Fortune.js uses an in-memory database. While this is fine for development purposes, it will not scale beyond a single thread nor will it persist data. What Fortune.js provides is an abstract base class for dealing with the database called the <code>Adapter</code>. To use an adapter, it must be specified. For example, using the Postgres adapter:</p><pre><code class="language-js"><span class="hljs-keyword">const</span> pgAdapter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fortune-postgres&#x27;</span>)

<span class="hljs-keyword">const</span> adapter = [ pgAdapter, {
  <span class="hljs-comment">// In this example, the Postgres adapter requires the connection URL.</span>
  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;postgres://postgres@localhost:5432/app_db&#x27;</span>
} ]

<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">fortune</span>(recordTypes, { adapter })
</code></pre><p>The adapter must implement the create, find, update, and delete methods. The find method specifies basic querying options, such as sorting, matching, ranges, existence, sparse fields, limit and offset. An adapter may optionally implement more adapter-specific queries, as well as transactions. In this case, the Postgres adapter implements transactions, so that each request to Fortune.js is atomic.</p><h2 id="internationalization">Internationalization<a class="anchor" href="#internationalization" title="Link to this section “Internationalization”">#</a></h2><p>In most real world applications, data must be validated for errors. Fortune.js exposes its own error classes and the <code>message</code> function to help translate errors to status codes and localized text. All of the error messages that Fortune.js uses internally and exposes to clients may be localized, and custom error messages may be specified like so:</p><pre><code class="language-js"><span class="hljs-keyword">const</span> { message } = fortune

<span class="hljs-comment">// Add application error messages in English (default language).</span>
<span class="hljs-comment">// More languages can be defined as keys on the `message` function.</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(message.<span class="hljs-property">en</span>, {
  <span class="hljs-string">&#x27;InvalidAuthorization&#x27;</span>: <span class="hljs-string">&#x27;The given user and/or password is invalid.&#x27;</span>,
  <span class="hljs-string">&#x27;InvalidPermission&#x27;</span>: <span class="hljs-string">&#x27;You do not have permission to do that.&#x27;</span>,
  <span class="hljs-string">&#x27;MissingField&#x27;</span>: <span class="hljs-string">&#x27;The required field &quot;{field}&quot; is missing.&#x27;</span>
})
</code></pre><p>It is entirely optional to use this feature, but it is provided since <code>Intl</code> is not defined in ES5. There is a <a href="http://wiki.ecmascript.org/doku.php?id=globalization:messageformatting">specification for message formatting</a> which should be preferred.</p><h2 id="input-and-output-hooks">Input and Output Hooks<a class="anchor" href="#input-and-output-hooks" title="Link to this section “Input and Output Hooks”">#</a></h2><p>Input and output hooks are user-defined functions which are run before writing a record, and after reading a record. They exist merely for convenience, one could also override the <code>request</code> method to implement the same functionality. These hooks are intended to isolate business logic, and any errors thrown here may be mapped to status codes. They may be specified like so:</p><pre><code class="language-js"><span class="hljs-keyword">const</span> hooks = {
  <span class="hljs-attr">user</span>: [ userInput, userOutput ],
  <span class="hljs-attr">post</span>: [ postInput ]
}

<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">fortune</span>(recordTypes, { hooks })
</code></pre><p>All of the arguments for the I/O hooks may be mutated. Any custom errors thrown will be displayed to client, while operational errors will be hidden (native errors such as <code>Error</code>).</p><p>For example, dealing with input for the <code>user</code> record type, a variety of authorization cases need to be handled. When creating a user, the name and password fields must be checked and the password must be encrypted, while updating and deleting require an authorization check.</p><pre><code class="language-js"><span class="hljs-keyword">const</span> { methods, <span class="hljs-attr">errors</span>: { <span class="hljs-title class_">BadRequestError</span> } } = fortune

<span class="hljs-keyword">function</span> <span class="hljs-title function_">userInput</span> (context, record, update) {
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">request</span>: { method, <span class="hljs-attr">meta</span>: { language } } } = context

  <span class="hljs-keyword">switch</span> (method) {
  <span class="hljs-keyword">case</span> methods.<span class="hljs-property">create</span>:
    <span class="hljs-comment">// Check for required fields.</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> field <span class="hljs-keyword">of</span> [ <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span> ])
      <span class="hljs-keyword">if</span> ((!field <span class="hljs-keyword">in</span> record)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadRequestError</span>(
        <span class="hljs-title function_">message</span>(<span class="hljs-string">&#x27;MissingField&#x27;</span>, language, { field }))

    <span class="hljs-keyword">const</span> { name, password } = record
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({ name }, <span class="hljs-title function_">makePassword</span>(password))

  <span class="hljs-keyword">case</span> methods.<span class="hljs-property">update</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">validateUser</span>(context, update.<span class="hljs-property">id</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">if</span> (update.<span class="hljs-property">replace</span>) {
        <span class="hljs-comment">// Only allow updates to name and password.</span>
        <span class="hljs-keyword">const</span> { <span class="hljs-attr">replace</span>: { name, password } } = update
        update.<span class="hljs-property">replace</span> = { name }
        <span class="hljs-keyword">if</span> (password) <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(update.<span class="hljs-property">replace</span>, <span class="hljs-title function_">makePassword</span>(password))
      }

      <span class="hljs-comment">// Only allow push/pull updates to follow and unfollow.</span>
      <span class="hljs-keyword">if</span> (update.<span class="hljs-property">push</span>) update.<span class="hljs-property">push</span> = { <span class="hljs-attr">following</span>: update.<span class="hljs-property">push</span>.<span class="hljs-property">following</span> }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (update.<span class="hljs-property">pull</span>) update.<span class="hljs-property">pull</span> = { <span class="hljs-attr">following</span>: update.<span class="hljs-property">pull</span>.<span class="hljs-property">following</span> }
    })

  <span class="hljs-keyword">case</span> methods.<span class="hljs-property">delete</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">validateUser</span>(context, record.<span class="hljs-property">id</span>)
  }
}
</code></pre><p>The password hashing function is an implementation detail. In this example, a hash function is used for the sake of simplicity, though a key derivation function or stronger should be used in real applications.</p><pre><code class="language-js"><span class="hljs-keyword">const</span> hashAlgorithm = <span class="hljs-string">&#x27;SHA256&#x27;</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">makePassword</span> (string) {
  <span class="hljs-keyword">const</span> salt = crypto.<span class="hljs-title function_">randomBytes</span>(<span class="hljs-number">32</span>)
  <span class="hljs-keyword">const</span> password = crypto.<span class="hljs-title function_">createHash</span>(hashAlgorithm)
    .<span class="hljs-title function_">update</span>(salt).<span class="hljs-title function_">update</span>(<span class="hljs-string">&#x27;&#x27;</span> + string).<span class="hljs-title function_">digest</span>()

  <span class="hljs-keyword">return</span> { salt, password }
}
</code></pre><p>The <code>validateUser</code> function is an implementation detail which may be shared across other hooks. For stateless protocols such as HTTP, the request parameters should contain all of the information necessary to make the request, including authorization credentials.</p><pre><code class="language-js"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>)

<span class="hljs-keyword">const</span> { <span class="hljs-attr">errors</span>: { <span class="hljs-title class_">UnauthorizedError</span>, <span class="hljs-title class_">ForbiddenError</span> } } = fortune

<span class="hljs-keyword">function</span> <span class="hljs-title function_">validateUser</span> (context, userId) {
  <span class="hljs-keyword">const</span> {
    <span class="hljs-attr">request</span>: { <span class="hljs-attr">meta</span>: { <span class="hljs-attr">headers</span>: { authorization }, language } },
    <span class="hljs-attr">response</span>: { meta }
  } = context

  <span class="hljs-comment">// Parse HTTP Basic Access Authentication.</span>
  <span class="hljs-keyword">const</span> [ userId, password ] = <span class="hljs-title function_">atob</span>(authorization.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">1</span>]).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;:&#x27;</span>)

  <span class="hljs-keyword">if</span> (!userId || !password) {
    <span class="hljs-keyword">if</span> (!meta.<span class="hljs-property">headers</span>) meta.<span class="hljs-property">headers</span> = {}
    meta.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;WWW-Authenticate&#x27;</span>] = <span class="hljs-string">&#x27;Basic realm=&quot;App name&quot;&#x27;</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnauthorizedError</span>(<span class="hljs-title function_">message</span>(<span class="hljs-string">&#x27;InvalidAuthorization&#x27;</span>, language))
  }

  <span class="hljs-keyword">const</span> options = { <span class="hljs-attr">fields</span>: { <span class="hljs-attr">password</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">salt</span>: <span class="hljs-literal">true</span> } }

  <span class="hljs-keyword">return</span> store.<span class="hljs-property">adapter</span>.<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;user&#x27;</span>, [ userId ], options).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> [ user ] = result
    <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForbiddenError</span>(<span class="hljs-title function_">message</span>(<span class="hljs-string">&#x27;InvalidPermission&#x27;</span>, language))

    <span class="hljs-keyword">if</span> (!user || (userId &amp;&amp; userId !== user.<span class="hljs-property">id</span>)) <span class="hljs-keyword">throw</span> error

    <span class="hljs-keyword">const</span> hash = crypto.<span class="hljs-title function_">createHash</span>(hashAlgorithm)
      .<span class="hljs-title function_">update</span>(user.<span class="hljs-property">salt</span>).<span class="hljs-title function_">update</span>(password).<span class="hljs-title function_">digest</span>()

    <span class="hljs-comment">// Prefer a constant-time equality check, this is not secure.</span>
    <span class="hljs-keyword">if</span> (!hash.<span class="hljs-title function_">equals</span>(user.<span class="hljs-property">password</span>)) <span class="hljs-keyword">throw</span> error

    <span class="hljs-keyword">return</span> user
  })
}
</code></pre><p>When reading a user, the password and salt must not be exposed. This can be done in the output hook:</p><pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">userOutput</span> (context, record) {
  <span class="hljs-keyword">delete</span> record.<span class="hljs-property">password</span>
  <span class="hljs-keyword">delete</span> record.<span class="hljs-property">salt</span>
}
</code></pre><p>The <code>post</code> type only needs to check for validity and whitelist fields that may be written.</p><pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">postInput</span> (context, record, update) {
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">request</span>: { method, <span class="hljs-attr">meta</span>: { language } } } = context

  <span class="hljs-keyword">switch</span> (method) {
  <span class="hljs-keyword">case</span> methods.<span class="hljs-property">create</span>:
    <span class="hljs-keyword">const</span> { text, parent } = record
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">validateUser</span>(context).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> ({
      text, parent, <span class="hljs-attr">createdAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), <span class="hljs-attr">author</span>: user.<span class="hljs-property">id</span>
    }))

  <span class="hljs-keyword">case</span> methods.<span class="hljs-property">update</span>:
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForbiddenError</span>(<span class="hljs-title function_">message</span>(<span class="hljs-string">&#x27;InvalidPermissions&#x27;</span>, language))

  <span class="hljs-keyword">case</span> methods.<span class="hljs-property">delete</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">validateUser</span>(context, record.<span class="hljs-property">author</span>)
  }
}
</code></pre><h2 id="networking">Networking<a class="anchor" href="#networking" title="Link to this section “Networking”">#</a></h2><p>All networking is external to Fortune.js. It makes no assumption that there is even a network at all. This makes it feasible to write applications which are decoupled from the network protocol.</p><p>There is a <code>fortune-http</code> package which maps requests and responses from the listener function arguments in Node.js to Fortune.js. What it does is implement relevant parts of the HTTP protocol such as content negotiation, status codes, caching and encoding. In the example above, error classes are used, and each error class maps to a status code.</p><p>A few basic serializers are included. To use it:</p><pre><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)
<span class="hljs-keyword">const</span> fortuneHTTP = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fortune-http&#x27;</span>)

<span class="hljs-keyword">const</span> listener = <span class="hljs-title function_">fortuneHTTP</span>(store, {
  <span class="hljs-comment">// The order specifies priority of media type negotiation.</span>
  <span class="hljs-attr">serializers</span>: [
    fortuneHTTP.<span class="hljs-property">JsonSerializer</span>,
    fortuneHTTP.<span class="hljs-property">HtmlSerializer</span>,
    fortuneHTTP.<span class="hljs-property">FormDataSerializer</span>,
    fortuneHTTP.<span class="hljs-property">FormUrlEncodedSerializer</span>
  ]
})

<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span>
  <span class="hljs-title function_">listener</span>(request, response)
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> { <span class="hljs-comment">/* error logging */</span> }))

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">1337</span>)
</code></pre><p>There is also a <code>fortune-ws</code> package, which may be useful for real-time updates. It implements a wire protocol that uses MessagePack as a serialization format.</p><p>Suppose that new posts from users who are followed should be sent. The client must initiate a state change containing users to follow, so that the server knows which posts to send.</p><pre><code class="language-js"><span class="hljs-keyword">const</span> fortuneWS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fortune-ws&#x27;</span>)

<span class="hljs-keyword">const</span> options = { <span class="hljs-attr">port</span>: <span class="hljs-number">1337</span> }
<span class="hljs-keyword">const</span> server = <span class="hljs-title function_">fortuneWS</span>(store, <span class="hljs-function">(<span class="hljs-params">state, changes</span>) =&gt;</span> {
  <span class="hljs-comment">// Whitelist state changes.</span>
  <span class="hljs-keyword">if</span> (!changes) <span class="hljs-keyword">return</span> { <span class="hljs-attr">users</span>: <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(state.<span class="hljs-property">users</span>) ? state.<span class="hljs-property">users</span> : [] }

  <span class="hljs-comment">// Only send new posts from users that are being followed.</span>
  <span class="hljs-keyword">if</span> (changes[methods.<span class="hljs-property">create</span>] &amp;&amp; changes[methods.<span class="hljs-property">create</span>].<span class="hljs-property">post</span>) {
    <span class="hljs-keyword">const</span> post = state.<span class="hljs-property">users</span> ? changes[methods.<span class="hljs-property">create</span>].<span class="hljs-property">post</span>
      .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">post</span> =&gt;</span> ~state.<span class="hljs-property">users</span>.<span class="hljs-title function_">indexOf</span>(post.<span class="hljs-property">author</span>)) : []

    <span class="hljs-keyword">if</span> (post.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> { [methods.<span class="hljs-property">create</span>]: { post } }
  }
}, options)
</code></pre><p>A web client can listen for changes:</p><pre><code class="language-js"><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(...)
<span class="hljs-keyword">const</span> users = [ ... ]

fortuneWS.<span class="hljs-title function_">request</span>(client, <span class="hljs-literal">null</span>, { users })
.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> fortuneWS.<span class="hljs-title function_">sync</span>(client, store))
</code></pre><h2 id="philosophy">Philosophy<a class="anchor" href="#philosophy" title="Link to this section “Philosophy”">#</a></h2><p>Most web applications are like skins around databases. Fortune.js provides an abstraction around core functionality of web applications. It is designed as a library which adds useful features on top of databases.</p><p>It avoids the Object-Relational or Object-Document Mapping problem by not dealing with <em>objects</em> in the Object-Oriented Programming sense. Records in Fortune.js do not inherit any classes and are just plain data structures.</p><p>It targets Node.js and web browsers with the same codebase, since the same concepts apply in both environments.</p><footer>&copy; 2021 &nbsp;&mdash;&nbsp; <a href="https://raw.githubusercontent.com/fortunejs/fortune/master/LICENSE">MIT License</a></footer></article><nav><div><h4>Docs <span class="version">(v5.5.18)</span></h4><ul><li><a href="../"><span>Readme</span></a></li><li><a href="../guide/"><span>Guide</span></a></li><li><a href="../api/"><span>API Reference</span></a></li><li><a href="../plugins/"><span>Plugins</span></a></li><li><a href="../concepts/"><span>Concepts</span></a></li><li><a href="../changelog/"><span>Changelog</span></a></li></ul><h4>Fortune</h4><ul><li><a href="../api/#fortune"><span>Fortune</span></a></li><li><a href="../api/#fortune-constructor"><span>constructor</span></a></li><li><a href="../api/#fortune-request"><span>request</span></a></li><li><a href="../api/#fortune-find"><span>find</span></a></li><li><a href="../api/#fortune-create"><span>create</span></a></li><li><a href="../api/#fortune-update"><span>update</span></a></li><li><a href="../api/#fortune-delete"><span>delete</span></a></li><li><a href="../api/#fortune-connect"><span>connect</span></a></li><li><a href="../api/#fortune-disconnect"><span>disconnect</span></a></li></ul><h4>Adapter</h4><ul><li><a href="../api/#adapter"><span>Adapter</span></a></li><li><a href="../api/#adapter-constructor"><span>constructor</span></a></li><li><a href="../api/#adapter-connect"><span>connect</span></a></li><li><a href="../api/#adapter-disconnect"><span>disconnect</span></a></li><li><a href="../api/#adapter-create"><span>create</span></a></li><li><a href="../api/#adapter-find"><span>find</span></a></li><li><a href="../api/#adapter-update"><span>update</span></a></li><li><a href="../api/#adapter-delete"><span>delete</span></a></li><li><a href="../api/#adapter-begintransaction"><span>beginTransaction</span></a></li><li><a href="../api/#adapter-endtransaction"><span>endTransaction</span></a></li><li><a href="../api/#adapter-applyoperators"><span>applyOperators</span></a></li></ul><h4>HTTP Server</h4><ul><li><a href="../api/#fortunehttp-createlistener"><span>createListener</span></a></li></ul><h4>HTTP Serializer</h4><ul><li><a href="../api/#httpserializer"><span>HttpSerializer</span></a></li><li><a href="../api/#httpserializer-constructor"><span>constructor</span></a></li><li><a href="../api/#httpserializer-processrequest"><span>processRequest</span></a></li><li><a href="../api/#httpserializer-processresponse"><span>processResponse</span></a></li><li><a href="../api/#httpserializer-parsepayload"><span>parsePayload</span></a></li><li><a href="../api/#httpserializer-mediatype"><span>mediaType</span></a></li></ul><h4>WebSocket</h4><ul><li><a href="../api/#fortunews-createserver"><span>createServer</span></a></li><li><a href="../api/#fortunews-request"><span>request</span></a></li><li><a href="../api/#fortunews-sync"><span>sync</span></a></li></ul><hr></div></nav></main><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.perfect-scrollbar/0.6.12/js/perfect-scrollbar.min.js"></script><script>Ps.initialize(document.querySelector('nav > div'))</script>